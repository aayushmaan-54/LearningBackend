# MongoDB Guide

## Installation
* Install MongoDB Community Server and MongoDB Shell (mongosh).

## Documents & Collections
* **Document:** A single record in a collection, stored in a JSON-like format (BSON - Binary JSON).
* **Collection:** A group of documents.
* **Example:** In a collection of users, each document contains user details. In an e-commerce app, there may be multiple collections like users, products, sellers, etc. All collections are grouped within a database, namely `ecommerce`.

## mongosh Commands

### Basic Commands
* `mongosh` - Open the MongoDB shell.
* `exit` or `quit()` - Exit out of mongosh.
* `db` - Show the current database.
* `show dbs` - Show all available databases.
* `use db_name` - Select a database named `db_name`. A non-existing database can also be selected, so be cautious with spelling mistakes.
* `show collections` - Show all collections in the selected database.
* `db.collection_name` - Returns `db_name.collection_name`.
* `db.dropDatabase()` - Delete the current database.
* `db.collection_name.drop()` - Delete a collection.
* `db.createCollection("collection_name")` - Explicitly create a new collection.
* `db.getCollectionNames()` - Get a list of all collections in the current database.
* `db.collection_name.stats()` - Get statistics on a collection.
* `db.serverStatus()` - Get server status information.

### Inserting Documents
* `db.collection_name.insertOne({...})` - Add a single document inside `{...}` to the collection. If the collection doesn't exist, it will be automatically created.
* `db.collection_name.insertMany([{...}, {...}, ...])` - Insert multiple documents.

### Querying Documents
* `db.collection_name.find()` - Print the first 20 documents.
  * `db.collection_name.find({ author: "john doe" })` - Find documents where the author is "john doe".
  * `db.collection_name.find({ author: "john doe", rating: 9 })` - Find documents where the author is "john doe" and the rating is 9.
  * `db.collection_name.find({ author: "john doe", rating: 9 }, { title: 1, author: 1 })` - Return the title and author of books whose author is "john doe" with a rating of 9.
  * `db.collection_name.find().count()` - Return the count of documents.
  * `db.collection_name.find().limit(3)` - Return only 3 documents.
  * `db.collection_name.find().sort({ title: 1 })` - Return documents in ascending order of title; use `-1` for descending order.
  * `db.collection_name.find().sort({ title: 1 }).limit(3)` - Return the first 3 documents sorted by title in ascending order.
* `db.collection_name.findOne({...})` - Find and return one document matching the criteria.

### Conditional Queries
* `db.collection_name.find({ rating: { $gt: 7 } })` - Return books with a rating greater than 7.
* `db.collection_name.find({ rating: { $lt: 7 } })` - Return books with a rating less than 7.
* `db.collection_name.find({ rating: { $lte: 7 } })` - Return books with a rating less than or equal to 7.
* `db.collection_name.find({ $or: [{ rating: 7 }, { rating: 9 }] })` - Return books with a rating of 7 or 9.
* `db.collection_name.find({ $or: [{ pages: { $lt: 300 } }, { pages: { $gt: 400 } }] })` - Return books with pages less than 300 or greater than 400.
* `db.collection_name.find({ rating: { $in: [7, 8, 9] } })` - Find books within this range.
* `db.collection_name.find({ rating: { $nin: [7, 8, 9] } })` - Find books **not** within this range.
* `db.collection_name.find({ genres: "fantasy" })` - If `genres` is an array, check if it contains "fantasy".
* `db.collection_name.find({ genres: ["fantasy"] })` - Find documents where the `genres` array has only one element: "fantasy".
* `db.collection_name.find({ genres: { $all: ["fantasy", "sci-fi"] } })` - Check if the array contains both "fantasy" and "sci-fi".
* `db.collection_name.find({ "reviews.name": "John Doe" })` - Check for a nested document where the review name is "John Doe".

### Updating Documents
* `db.collection_name.updateOne({ _id: ObjectId("...") }, { $set: { author: "John Doe", pages: 360 } })` - Update document by setting specified values.
* `db.collection_name.updateMany({ author: "Johnny" }, { $set: { author: "John Doe" } })` - Update all documents with author "Johnny".
* `db.collection_name.updateOne({ _id: ObjectId("...") }, { $inc: { pages: 45 } })` - Increment the pages of the document by 45.
* `db.collection_name.updateOne({ _id: ObjectId("...") }, { $inc: { pages: -45 } })` - Decrement the pages of the document by 45.
* `db.collection_name.updateOne({ _id: ObjectId("...") }, { $pull: { genres: "fantasy" } })` - Remove "fantasy" from the genres array of the specified document.
* `db.collection_name.updateOne({ _id: ObjectId("...") }, { $push: { genres: "fantasy" } })` - Add "fantasy" back to the genres array of the specified document.
* `db.collection_name.updateOne({ _id: ObjectId("...") }, { $push: { genres: { $each: ["magic", "horror"] } } })` - Push "magic" and "horror" into the genres array of the specified document.

### Deleting Documents
* `db.collection_name.deleteOne({ ... })` - Delete a document matching the criteria specified in `{...}`.
* `db.collection_name.deleteMany({ ... })` - Delete all documents matching the criteria specified in `{...}`.

### Ordered & Unordered Insertion Operations

### Import and Export of JSON Documents

### Cursors
* MongoDb reterives query results in batches using cursor, cursor is a pointer to result set, they are used to iterate through query result.
* default size of batches us usually 101 documents
* count(), limit(), skip(), sort() are cursor methods, these affect performance significantly so use indexing to improve performance

### expr operators
* `$expr` allows using aggregation expressions within a query
* useful when you need a to compare fields from the same document in a more complex manner
* ex: find sales price where quantity * price > targetPrice
`
db.sales.find({
  $expr: {
    $gt: [
      { $multiply: ['$quantity', '$price'] },
      '$targetPrice'
    ]
  }
})
`

### Elements Operator
* `$exists` - 
* `$type` - 
* `$size` - 

### `$all` vs `$elemMatch`

### indexes
* indexes are specialized data structure that optimize data retrieval speed in MongoDb
* indexes are seperate from collesctions and multiple indexes can exsist per collection
* `db.collection_name.find({...}).explain()` - method to understand query execution in detail
* `db.collection_name.find({...}).explain("executionStats")` - returns extra object with info about time taken and more
* `db.collection_name.createIndex({ field: 1 })` - 1 for sorting in ascending and -1 for descending
* `db.collection_name.getIndexes()` - _id is a default index
* `db.collection_name.dropIndex({ field: 1 })`
* `db.collection_name.dropIndex("index_name")`
* `db.collection_name.createIndex({ 'key': value })`
* `db.collection_name.createIndex({ 'key': value }, { unique: true })` 
* indexes should not be created on queries that is rarely used as it creates its own seperate space aside from collections
* in small collection indexes might outweight the benifits gained


### Aggregation
* aggregation is the process of performing transformations on documents and combining them to produce computed results
* aggregations consist of multiple pipelines stages, each performing a specific operation on input data
* `db.collection_name.aggregate([{ $match: {key: value} }])`
* db.collection_name.aggregate([{$group: {_id: {key: "$value}, totalProd: {$sum: 1}}}])
* $sort
* $project
* $push
* $unwind
* $addToSet
* $size
* $filter


* Organization -> cluster -> projects -> database -> collection -> document